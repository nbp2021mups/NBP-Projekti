*** neo4j ***

- Graph database
- Glavni use-case jeste kod baza koje imaju mnogo veza
- Dve vrste objekata:
	- Čvorovi
	- Relacije (potezi)
	
* Ovo znači da možemo da tipiziramo i čvorove i potege uz pomoć labela, kao i da im dodeljujemo proizvoljan broj karakteristika (atributa/properties).
* Labele (oznake) predstavljaju zapravo tipove objekata (tipizacija) i koriste se kasnije za lakše pretraživanje
* neo4j automatski dodeljuje id property, ukoliko korisnik sam ne precizira

* Svaka relacija (poteg) može da bude tipizirana i objekat je sama za sebe.

* Razlikuje se direktivnost relacija (potega):
	- Jednosmerne
	- Dvosmerne
* Direktivnost je bitna prilikom pretrage, odnosno upita. Pri pisanju upita može da se naglasi da vodi računa o direktivnosti, tj. ukoliko krenemo iz A i imamo relaciju A--Relacija-->B, možemo da pročitamo put do B kao validan, ali iz B ka A nemamo put. Ukoliko se upit kreira bez direktivnosti, onda možemo da dobijemo i put B ka A.

* Cypher je upitni jezik napisan za neo4j i kreatori su se trudili da liči na SQL, jer je to dugo bio standard.
* Klauzule Cypher-a:
	- Match, iza kog sledi pattern (šablon)
		=> naredba koja pokušava da pronađe put unutar grafa koji odgovara paternu i vraća sve puteve(lance) koji odgovaraju pridodatom šablonu
	- Return (Select kao analogija sa SQL-om) => vrši projekciju rezultata (puta/lanca) na određene property-je.
	- Moguće je definisanje alias-a za "međurezultate" (kao AS u SQL-u)
	- Create [json <=> key, value pair] => za kreiranje novih objekata (čvorova/potega(reacija)) neo4j slepo sluša, odnosno možemo napraviti identične čvorove (ispod haube drugi id, ali sve ostalo isto)
	- Match (obrazac) Set (...) => Koristi se za ažurianje na nivou property-ja objekata
	- Delete => koristi se za brisanje OBJEKATA i to SAMO UKOLIKO NEMAJU NIJEDNU VEZU
	- Detach delete => uz brisanje objekta brišu se i sve veze
	- Update property_name:null => setovanje property-ja na null (neka vrsta uklanjanja property-ja)
	- Remove property_name => uklanjanje property-ja iz STRUKTURE objekta
	- Exists(property) => provera da li postoji property (nije kao OOP), jer sa remove može da se ukloni
	- Merge (Select or Insert) => za kreiranje objekata, ali neo4j provera da li postoji već identična struktura
	- Where (Identično SQL-u)
		- STAY AWAY FROM DATES (basic poređenje radi, ali ukoliko je potrebno nešto napredno...)
		- StartsWith, Contains, EndsWith za stringove
	- Optional Match (opciono preklapanje pattern-a) <=> Left/Right join u SQL-u
	- Count
	- Distinct
	- Collect
	- Unwind
	- Order by
	- Limit
	- ".*" <=> "%" u SQL-u => može se naći
	- "=~" <=> LIKE u SQL-u
	- "start n=node(*)" - starija sintaksa (novije i bolje "MATCH (n)") - kreni od bilo kog čvora


*** Demo ***


new GraphClient(new Uri("http://localhost:7474/db/data":defaultUrl, "neo4j":defaultUsername, "neo4j":defaultPass))

var query = new CypherQuery("start n=node(*) where (n:Actor) and exists(n.name) and n.name =~ {actorName} return n", queryDict, CypherResultMode.Set);


queryDict => dictionary koji za ključeve sadrži parametrizovane stringove koji se nalaze unutar {}, a za vrednosti ono čime se ti parametrizovani stringovi query string-a menjaju.
Prethodno odradimo
var queryDict = new Dictionary()<string, object>;
queryDict.Add("actorName", "Nina");
i time se dobije query 
start n=node(*) where (n:Actor) and exists(n.name) and n.name =~ Nina return n


Posle može da se odradi deserializacija
List<Actor> actors = ((IRawGraphClient)client).ExecuteGetCypherResults<Actor>(query).ToList();
// Uparivanje property-ja čvora i instanci domenskog modela na osnovu naziva property-ja


// Upit koji pronalazi sve čvorove koji su relacijom ACTS_IN povezani ka čvoru n, koji ima title property i taj property sadrži movieName
start n=node(*) match (n)<-[r:ACTS_IN]-(a) where exists(n.title) and n.title =~ {movieName} return a

// Upit koji vraća sve čvorove prema kojima je čvor n koji ima name property i taj property sadrži directorName usmeren relacijom (potegom) sa labelom (tipizacijom) DIRECTED
start n=node(*) match (n)-[r:DIRECTED]->(m) where exists(n.name) and n.name =~ {directorName} return m

// Upit koji vraća sve čvorove čiji su potezi da tipizacijom ACTS_IN usmereni ka čvorovima m prema kojima su tipizacijom DIRECTED usmereni čvorovi n, koji imaju property name i taj property sadrži directorName
start n=node(*) match (n)-[r:DIRECTED]->(m)<-[r1:ACTS_IN]-(a) where exists(n.name) and n.name =~ {directorName} return a


// Kreiranje, bez provere da li postoji ovakav čvor, ukoliko je potrebno da bude jedinsvetno, onda koristiti Merge
Create (n:Actor {id:'', name:'', birthday:'', birthPlace:'', biography:''}) return n

* Postoji mogućnost (biblioteka) u .net-u da se koristi umesto pisanja raw query stringova, "fluid pristup, kao LINQ", nadovezivanje .Match().Where()... itd...